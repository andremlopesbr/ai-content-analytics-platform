import { injectable, inject } from 'tsyringe';
import * as puppeteer from 'puppeteer';
import { Report } from '../../domain/entities/Report';
import { IReportRepository } from '../../domain/repositories/IReportRepository';
import { AppError } from '../../shared/errors/AppError';

export interface ExportReportPdfRequest {
  reportId: string;
}

export interface ExportReportPdfResponse {
  pdfBuffer: Buffer;
  filename: string;
}

@injectable()
export class ExportReportPdfUseCase {
  constructor(
    @inject('IReportRepository') private reportRepository: IReportRepository,
  ) {}

  async execute(request: ExportReportPdfRequest): Promise<ExportReportPdfResponse> {
    const report = await this.reportRepository.findById(request.reportId);

    if (!report) {
      throw new AppError('Report not found', 404);
    }

    const htmlContent = this.generateHtmlTemplate(report);
    const pdfBuffer = await this.generatePdf(htmlContent);

    const filename = `report-${report.id}-${new Date().toISOString().split('T')[0]}.pdf`;

    return {
      pdfBuffer,
      filename,
    };
  }

  private generateHtmlTemplate(report: Report): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${report.title}</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            margin: 40px;
            color: #333;
          }
          .header {
            border-bottom: 2px solid #007bff;
            padding-bottom: 20px;
            margin-bottom: 30px;
          }
          .title {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
          }
          .metadata {
            margin-bottom: 20px;
            font-size: 14px;
            color: #666;
          }
          .section {
            margin-bottom: 30px;
          }
          .section-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #007bff;
          }
          .data-list {
            margin-left: 20px;
          }
          .data-item {
            margin-bottom: 5px;
          }
          .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
          }
          .table th, .table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
          }
          .table th {
            background-color: #f2f2f2;
            font-weight: bold;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="title">${report.title}</div>
          <div class="metadata">
            <div>Type: ${report.type.replace('_', ' ').toUpperCase()}</div>
            <div>Generated: ${report.createdAt.toLocaleDateString()}</div>
            ${report.generatedBy ? `<div>Generated by: ${report.generatedBy}</div>` : ''}
          </div>
        </div>

        ${this.renderReportData(report)}
      </body>
      </html>
    `;
  }

  private renderReportData(report: Report): string {
    const { data } = report;

    switch (report.type) {
      case 'content_summary':
        return this.renderContentSummary(data);
      case 'trend_analysis':
        return this.renderTrendAnalysis(data);
      case 'performance_metrics':
        return this.renderPerformanceMetrics(data);
      default:
        return this.renderCustomReport(data);
    }
  }

  private renderContentSummary(data: any): string {
    const summary = data.summary || {};
    const topTags = data.topTags || [];

    return `
      <div class="section">
        <div class="section-title">Content Summary</div>
        <div class="data-list">
          <div class="data-item">Total Contents: ${summary.totalContents || 0}</div>
          <div class="data-item">Unique Authors: ${summary.uniqueAuthors || 0}</div>
          ${summary.dateRange?.from ? `<div class="data-item">Date Range: ${new Date(summary.dateRange.from).toLocaleDateString()} - ${new Date(summary.dateRange.to).toLocaleDateString()}</div>` : ''}
        </div>
        ${topTags.length > 0 ? `
          <div class="section-title">Top Tags</div>
          <table class="table">
            <thead>
              <tr>
                <th>Tag</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody>
              ${topTags.map(([tag, count]: [string, number]) => `<tr><td>${tag}</td><td>${count}</td></tr>`).join('')}
            </tbody>
          </table>
        ` : ''}
      </div>
    `;
  }

  private renderTrendAnalysis(data: any): string {
    const trends = data.trends || {};
    const sentimentDistribution = trends.sentimentDistribution || {};
    const topKeywords = trends.topKeywords || [];

    return `
      <div class="section">
        <div class="section-title">Trend Analysis</div>
        ${Object.keys(sentimentDistribution).length > 0 ? `
          <div class="section-title">Sentiment Distribution</div>
          <table class="table">
            <thead>
              <tr>
                <th>Sentiment</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody>
              ${Object.entries(sentimentDistribution).map(([sentiment, count]: [string, any]) => `<tr><td>${sentiment}</td><td>${count}</td></tr>`).join('')}
            </tbody>
          </table>
        ` : ''}
        ${topKeywords.length > 0 ? `
          <div class="section-title">Top Keywords</div>
          <table class="table">
            <thead>
              <tr>
                <th>Keyword</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody>
              ${topKeywords.map(([keyword, count]: [string, number]) => `<tr><td>${keyword}</td><td>${count}</td></tr>`).join('')}
            </tbody>
          </table>
        ` : ''}
        ${trends.averageReadability ? `<div class="data-item">Average Readability Score: ${trends.averageReadability.toFixed(2)}</div>` : ''}
      </div>
    `;
  }

  private renderPerformanceMetrics(data: any): string {
    const metrics = data.metrics || {};

    return `
      <div class="section">
        <div class="section-title">Performance Metrics</div>
        <div class="data-list">
          <div class="data-item">Total Analyses: ${metrics.totalAnalyses || 0}</div>
          <div class="data-item">Completed Analyses: ${metrics.completedAnalyses || 0}</div>
          <div class="data-item">Failed Analyses: ${metrics.failedAnalyses || 0}</div>
          <div class="data-item">Success Rate: ${metrics.successRate ? metrics.successRate.toFixed(2) : 0}%</div>
          ${metrics.averageProcessingTimeMs ? `<div class="data-item">Average Processing Time: ${(metrics.averageProcessingTimeMs / 1000).toFixed(2)}s</div>` : ''}
        </div>
      </div>
    `;
  }

  private renderCustomReport(data: any): string {
    const custom = data.custom || {};

    return `
      <div class="section">
        <div class="section-title">Custom Report</div>
        <div class="data-list">
          <div class="data-item">Content Count: ${custom.contentCount || 0}</div>
          <div class="data-item">Analysis Count: ${custom.analysisCount || 0}</div>
          <div class="data-item">Generated At: ${custom.generatedAt ? new Date(custom.generatedAt).toLocaleString() : 'N/A'}</div>
        </div>
      </div>
    `;
  }

  private async generatePdf(htmlContent: string): Promise<Buffer> {
    let browser;
    try {
      browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });

      const page = await browser.newPage();
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });

      const pdfBuffer = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20px',
          right: '20px',
          bottom: '20px',
          left: '20px',
        },
      });

      return pdfBuffer;
    } catch (error) {
      throw new AppError('Failed to generate PDF', 500);
    } finally {
      if (browser) {
        await browser.close();
      }
    }
  }
}